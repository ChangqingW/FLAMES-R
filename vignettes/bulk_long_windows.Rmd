---
title: "Vignette for FLAMES on Windows"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Windows FLAMES Bulk Pipeline
Windows is capable of running the FLAMES pipeline, with only read alignment and realignment requiring access to a MacOS or Linux distribution to complete.

In order to run the FLAMES bulk pipeline on Windows, ensure that the arguments do_genome_align and do_read_realign are set to FALSE.
```{r eval=FALSE}
bulk_long_pipeline <- function(..., do_genome_align=FALSE, do_read_realign=FALSE) {
```

Alternatively, the FLAMES pipeline can be manually executed using exported functions from the FLAMES package, and minimap2 alignment can be performed externally to complete the read alignment and realignment processes.

This process is outlined below.

***
## Manual execution of FLAMES pipeline

```{r eval=FALSE, echo=FALSE} 
#THESE NEED TO BE PART OF THE SCRIPT THAT RUNS?????????? Should this vignette be run to build?
```
### Environment setup
Begin by storing the variables `annot`, `fastq`, `outdir`, `genome_fa`, `minimap2_dir`, `downsample_ratio`, `config_file` in the current workspace, as you would for calling `bulk_long_pipeline` function. Ensure `outdir` exists, and is writable. More information on the values of these variables can be obtained by executing:
```{r eval=FALSE}
?FlamesR::bulk_long_pipeline
```

After these are stored, all fastq files located in the directory `fastq` can be merged running:
```{r eval=FALSE}
library(FlamesR)
infq <- paste(outdir, "merged.fastq.gz", sep="/")
bc_file <- paste(outdir, "pseudo_barcode_annotation.csv", sep="/")

# run the merge_bulk_fastq function as preprocessing
merge_bulk_fastq(fastq, bc_file, infq)
```

A few intermediate files and variables need to be created before the pipeline can proceed:
```{r eval=FALSE}
# setup of internal arguments which hold output files and intermediate files
isoform_gff3 = paste(outdir, "isoform_annotated.gff3", sep="/")
isoform_gff3_f = paste(outdir, "isoform_annotated.filtered.gff3", sep="/")
FSM_anno_out = paste(outdir, "isoform_FSM_annotation.csv", sep="/")
raw_splice_isoform = paste(outdir, "splice_raw.gff3", sep="/")
tss_tes_stat = paste(outdir, "tss_tes.bedgraph", sep="/")
transcript_fa = paste(outdir, "transcript_assembly.fa", sep="/")
transcript_fa_idx = paste(outdir, "transcript_assembly.fa.fai", sep="/")
tmp_bam = paste(outdir, "tmp.align.bam", sep="/")
tmp_bed = paste(outdir, "tmp.splice_anno.bed12", sep="/")
genome_bam = paste(outdir, "align2genome.bam", sep="/")
realign_bam = paste(outdir, "realign2transcript.bam", sep="/")
tr_cnt_csv = paste(outdir, "transcript_count.csv.gz", sep="/")
tr_badcov_cnt_csv = paste(outdir, "transcript_count.bad_coverage.csv.gz", sep="/")
```
The JSON configuration file should also be loaded into R, using: 
```{r eval=FALSE}
parse_json_config(config_file)
```
If a FLAMES configuration file doesn't exist, one can be created using user specified values, and loaded into R using the function `FlamesR::create_config()`. 

### FLAMES Execution


#### Genome Alignment
If genome alignment is required, this should be performed on a system with access to minimap2. The code required to
run this is provided below. After this is executed and resulting data transfered to this workspace, the Windows FLAMES bulk pipeline can proceed.
```{r eval=FALSE}
# below code must be run with access to minimap2
tmp_bed <- paste(outdir, "tmp.splice_anno.bed12", sep=.Platform$file.sep)
tmp_bam <- paste(outdir, "tmp.align.bam", sep=.Platform$file.sep)

gff3_to_bed12(minimap2_dir, annot, tmp_bed)

minimap2_align(minimap2_dir, genome_fa, infq, tmp_bam,
    no_flank=config$alignment_parameters$no_flank, bed12_junc=if (config$alignment_parameters$use_junctions) tmp_bed else NULL)
samtools_sort_index(tmp_bam, genome_bam)
file.remove(tmp_bam)
  # if options: use_junctions
  file.remove(tmp_bed)
```


#### Isoform Identification
Next, the annotation file in gff3 format needs to be parsed and loaded into R.
```{r eval=FALSE}
gff3 <- parse_gff_tree(annot)
remove_similar_tr(gff3&$gene_to_transcript, gff3$transcript_to_exon)
```
Then, if isoform identification is required, the below code block should be executed. --- WHAT DOES group_bam2isoform do??
```{r eval=FALSE}
transcript_to_junctions = list()
for (tr in names(transcript_to_exon)) {
  transcript_to_junctions[[tr]] = blocks_to_junctions(transcript_to_exon[[tr]])
}

gene_dict <- get_gene_flat(gff3$gene_to_transcript, gff3$transcript_to_exon)
chr_to_blocks <- get_gene_blocks(gene_dict, gff3$chr_to_gene, gff3$gene_to_transcript)
group_bam2isoform(genome_bam, isoform_gff3, tss_tes_stat, "", chr_to_blocks,
    gene_dict, transcript_to_junctions, gff3$transcript_dict, genome_fa,
    config=config$isoform_parameters, downsample_ratio=downsample_ratio,
    raw_gff3=if (config$global_parameters$generate_raw_isoform) raw_splice_isoform else NULL)
```
Following isoform identification, the isoform gff3 file created from the above call to `group_bam2isoform` needs to be parsed and loaded into R. get_transcript_seq?? WHY IS THIS EXECUTED EVERY TIME IF ISOFORM_GFF3 IS ONLY CREATED WHEN ABOVE IS RUN? WHICH IS ONLY RUN IF do_isoform_identification is TRUE?????
```{r eval=FALSE}
gff3_isoform <- parse_gff_tree(isoform_gff3)

if (!config$realign_parameters$use_annotation) gff3 = NULL
get_transcript_seq(genome_fa, transcript_fa, gff3_isoform$chr_to_gene_i, gff3_isoform$transcript_dict_i,
        gff3_isoform$gene_to_transcript_i, gff3_isoform$transcript_to_exon_i, ref_dict=gff3)
```


#### Read Realignment
If read realignment is required, this should again be done on a system with access to minimap2. The code below details how this is accomplished, using functions from the FlamesR package.
```{r eval=FALSE}
tmp_bam <- paste(outdir, "tmp.align.bam", sep=.Platform$file.sep)
minimap2_tr_align(minimap2_dir, transcript_fa, infq, tmp_bam)
samtools_sort_index(tmp_bam, realign_bam)
file.remove(tmp_bam)
```


#### Transcript Quantification
Finally, transcript quantification can be performed, as required:
```{r eval=FALSE}
parse_realign <- parse_realigned_bam(realign_bam, transcript_fa_idx,
    config$isoform_parameters$Min_sup_cnt,
    config$transcript_counting$min_tr_coverage,
    config$transcript_counting$min_read_coverage,
    bc_file=bc_file)
    tr_cnt = wrt_tr_to_csv(parse_realign$bc_tr_count_dict, gff3_isoform$transcript_dict_i, tr_cnt_csv, transcript_dict, config$global_parameters$has_UMI)
    wrt_tr_to_csv(parse_realign$bc_tr_badcov_count_dict, gff3_isoform$transcript_dict_i, tr_badcov_cnt_csv, transcript_dict, config$global_parameters$has_UMI)
    annotate_filter_gff(isoform_gff3, annot, isoform_gff3_f, FSM_anno_out, tr_cnt, config$isoform_parameters$Min_sup_cnt)
```

