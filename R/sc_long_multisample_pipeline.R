#' Pipeline for Multi-sample Single Cell Data
#'
#' @md
#'
#' @description
#' Semi-supervised isoform detection and annotation for long read data.
#' This variant is for multi-sample single cell data. By default, this pipeline demultiplexes input
#' fastq data (\code{match_cell_barcode = TRUE}). Specific parameters relating to
#' analysis can be changed either through function arguments, or through a
#' configuration JSON file.
#'
#' @details
#' By default FLAMES use minimap2 for read alignment. After the genome alignment step (\code{do_genome_align}), FLAMES summarizes the alignment for each read in every sample by grouping reads
#' with similar splice junctions to get a raw isoform annotation (\code{do_isoform_id}). The raw isoform
#' annotation is compared against the reference annotation to correct potential splice site
#' and transcript start/end errors. Transcripts that have similar splice junctions
#' and transcript start/end to the reference transcript are merged with the
#' reference. This process will also collapse isoforms that are likely to be truncated
#' transcripts. Next is the read realignment step (\code{do_read_realign}), where the sequence of each polished transcript is extracted and used as
#' the updated reference. The reads are realigned to this reference by minimap2. The
#' transcripts with only a few full-length aligned reads are discarded.
#' The reads are assigned to transcripts based on both alignment score, fractions of
#' reads aligned and transcript coverage. Reads that cannot be uniquely assigned to
#' transcripts or have low transcript coverage are discarded. The UMI transcript
#' count matrix is generated by collapsing the reads with the same UMI in a similar
#' way to what is done for short-read scRNA-seq data, but allowing for an edit distance
#' of up to 2 by default. Most of the parameters, such as the minimal distance to splice site and minimal percentage of transcript coverage
#' can be modified by the JSON configuration file (\code{config_file}).
#'
#' @param annot The file path to gene annotations file in gff3  format
#' @param fastqs A vector containing the paths to each fastq files. If \code{in_bams} is not provided, this argument can also
#' be provided as the path to the folder containing the fastq files. Each fastq file will be treated as a sample.
#' @param in_bams Optional vector containing file paths the  bam files to use instead of fastq file (skips initial alignment step).
#' The order of the bam files need to mach the order in \code{fastqs}.
#' @param outdir The path to directory to store all output files.
#' @param genome_fa The file path to genome fasta file.
#' @param minimap2_dir Path to the directory containing minimap2, if it is not in PATH. Only required if either or both of
#' \code{do_genome_align} and \code{do_read_realign} are \code{TRUE}.
#' @param downsample_ratio Integer; downsampling ratio if performing downsampling analysis.
#' @param config_file File path to the JSON configuration file. If specified, \code{config_file} overrides
#' all configuration parameters
#' @param do_genome_align Boolean; specifies whether to run the genome alignment step. \code{TRUE} is recommended
#' @param do_isoform_id Boolean; specifies whether to run the isoform identification step. \code{TRUE} is recommended
#' @param do_read_realign Boolean; specifies whether to run the read realignment step. \code{TRUE} is recommended
#' @param do_transcript_quanti Boolean; specifies whether to run the transcript quantification step. \code{TRUE} is recommended
#' @param gen_raw_isoform Boolean; specifies whether a gff3 should be generated containing the raw isoform information in the isoform identification step
#' @param has_UMI Boolean; specifies if the data contains UMI.
#' @param MAX_DIST Real; maximum distance allowed when merging splicing sites in isoform consensus clustering.
#' @param MAX_TS_DIST Real; maximum distance allowed when merging transcript start/end position in isoform consensus clustering.
#' @param MAX_SPLICE_MATCH_DIST Real; maximum distance allowed when merging splice site called from the data and the reference annotation.
#' @param min_fl_exon_len Real; minimum length for the first exon outside the gene body in reference annotation. This is to correct the alignment artifact
#' @param Max_site_per_splice Real; maximum transcript start/end site combinations allowed per splice chain
#' @param Min_sup_cnt Real; minimum number of read support an isoform. Decreasing this number will significantly increase the number of isoform detected.
#' @param Min_cnt_pct Real; minimum percentage of count for an isoform relative to total count for the same gene.
#' @param Min_sup_pct Real; minimum percentage of count for an splice chain that support a given transcript start/end site combination.
#' @param strand_specific 1, -1 or 0. 1 indicates if reads are in the same
#' strand as mRNA, -1 indicates reads are reverse complemented, 0 indicates
#' reads are not strand specific.
#' @param remove_incomp_reads Real; determines the strength of truncated isoform filtering. Larger number means more stringent filtering.
#' @param use_junctions Boolean; determiens whether to use known splice junctions to help correct the alignment results
#' @param no_flank Boolean; passed to minimap2 for synthetic spike-in data. Refer to Minimap2 document for more details
#' @param use_annotation Boolean; specifies whether to use reference to help annotate known isoforms
#' @param min_tr_coverage Real; minimum percentage of isoform coverage for a read to be aligned to that isoform
#' @param min_read_coverage Real; minimum percentage of read coverage for a read to be uniquely aligned to that isoform
#' @param UMI_LEN Integer; the length of UMI sequence in bases
#' @param reference_csv The file path to the reference csv used for demultiplexing
#' @param match_barcode Boolean; specifies if demultiplexing should be performed using `FLAMES::match_cell_barcode`
#' @return \code{sc_long_pipeline} returns a SingleCellExperiment object, containing a count
#' matrix as an assay, gene annotations under metadata, as well as a list of the other
#' output files generated by the pipeline. The pipeline also outputs a number of output
#' files into the given \code{outdir} directory. These output files generated by the pipeline are:
#' \itemize{
#'  \item{transcript_count.csv.gz}{ - a transcript count matrix (also contained in the SingleCellExperiment)}
#'  \item{isoform_annotated.filtered.gff3}{ - isoforms in gff3 format (also contained in the SingleCellExperiment)}
#'  \item{transcript_assembly.fa}{ - transcript sequence from the isoforms}
#'  \item{align2genome.bam}{ - sorted BAM file with reads aligned to genome}
#'  \item{realign2transcript.bam}{ - sorted realigned BAM file using the transcript_assembly.fa as reference}
#'  \item{tss_tes.bedgraph}{ - TSS TES enrichment for all reads (for QC)}
#' }
#'
#' @details The default parameters can be changed either through the function
#' arguments are through the configuration JSON file \code{config_file}. the \code{pipeline_parameters}
#' section specifies which steps are to be executed in the pipeline - by default, all
#' steps are executed. The \code{isoform_parameters} section affects isoform detection - key
#' parameters include:
#' \itemize{
#'  \item{\code{Min_sup_cnt}}{ which causes transcripts with less reads aligned than
#' it's value to be discarded}
#'  \item{\code{MAX_TS_DIST}}{ which merges transcripts with the same intron
#' chain and TSS/TES distace less than \code{MAX_TS_DIST}}
#'  \item{\code{strand_specific}}{ which specifies if reads are in the same strand as the mRNA (1),
#' or the reverse complemented (-1) or not strand specific (0), which results in
#' strand information being based on reference annotation.}
#' }
#'
#' @seealso
#' [bulk_long_pipeline()] for bulk long data,
#' [SingleCellExperiment()] for how data is outputted
#'
#' @importFrom dplyr group_by summarise_at slice_max filter
#' @importFrom magrittr "%>%"
#' @importFrom SingleCellExperiment SingleCellExperiment reducedDimNames logcounts
#' @importFrom SummarizedExperiment rowData colData rowData<- colData<- rowRanges rowRanges<-
#' @importFrom BiocGenerics cbind colnames rownames start end
#' @importFrom utils read.csv read.table
#'
#' @example inst/examples/pipeline_example.R
#' @export
sc_long_multisample_pipeline <-
    function(annot,
             fastqs,
             in_bams = NULL,
             outdir,
             genome_fa,
             minimap2_dir = "",
             downsample_ratio = 1,
             reference_csv,
             match_barcode = TRUE,
             config_file = NULL,
             do_genome_align = TRUE,
             do_isoform_id = TRUE,
             do_read_realign = TRUE,
             do_transcript_quanti = TRUE,
             gen_raw_isoform = TRUE,
             has_UMI = FALSE,
             UMI_LEN = 10,
             MAX_DIST = 10,
             MAX_TS_DIST = 100,
             MAX_SPLICE_MATCH_DIST = 10,
             min_fl_exon_len = 40,
             Max_site_per_splice = 3,
             Min_sup_cnt = 10,
             Min_cnt_pct = 0.01,
             Min_sup_pct = 0.2,
             strand_specific = 1,
             remove_incomp_reads = 5,
             use_junctions = TRUE,
             no_flank = TRUE,
             use_annotation = TRUE,
             min_tr_coverage = 0.75,
             min_read_coverage = 0.75) {
        checked_args <- check_arguments(annot,
            fastqs,
            in_bams,
            outdir,
            genome_fa,
            minimap2_dir,
            downsample_ratio,
            config_file,
            do_genome_align,
            do_isoform_id = TRUE,
            do_read_realign,
            do_transcript_quanti,
            gen_raw_isoform,
            has_UMI,
            MAX_DIST,
            MAX_TS_DIST,
            MAX_SPLICE_MATCH_DIST,
            min_fl_exon_len,
            Max_site_per_splice,
            Min_sup_cnt,
            Min_cnt_pct,
            Min_sup_pct,
            strand_specific,
            remove_incomp_reads,
            use_junctions,
            no_flank,
            use_annotation,
            min_tr_coverage,
            min_read_coverage
        )

        config_file <- checked_args$config

        # check fastqs
        if (length(fastqs) == 1) {
            if (file_test("-f", fastqs)) {
                stop("Only one fastq file provided, did you meant to used the single-sample pipeline (FLAMES::sc_long_pipeline) ?")
            }

            fastqs <- file.path(fastqs, list.files(fastqs))
            fastqs <- fastqs[endsWith(fastqs, ".fq") | endsWith(fastqs, ".fastq")]
            if (length(fastqs) == 0) {
                stop("No .fq or .fastq files found")
            }
            cat("Fastq files found:\n")
            cat(paste0(fastqs, sep = "\n"))
            if (match_barcode) {
                stop("If \"match_barcode\" set to TRUE, argument \"fastqs\" must be a list of fastq files, with the same order in \"reference_csv\"")
            }
        } else if (any(!file.exists(fastqs))) {
            stop("Please make sure all fastq files exist.")
        }

        samples <- gsub(".fq$", "", gsub(".fastq$", "", basename(fastqs)))

        if (match_barcode) {
            if (!all(file.exists(reference_csv)) || length(reference_csv) != length(fastqs)) {
                stop("A reference_csv must exists for every fastq file.")
            }

            # speed up with lapply?
            infqs <- file.path(outdir, paste(samples, "matched_reads.fastq.gz", sep = "_"))
            bc_stats <- file.path(outdir, paste(samples, "matched_barcode_stat", sep = "_"))
            for (i in length(fastqs)) {
                match_cell_barcode(
                    fastqs[i],
                    bc_stats[i],
                    infqs[i],
                    reference_csv[i],
                    MAX_DIST,
                    UMI_LEN
                )
            }
        } else {
            infqs <- fastqs
        } # requesting to not match barcodes implies `fastq` has already been run through the
        # function in a previous FLAMES call


        cat("Running FLAMES pipeline...\n")
        config <- parse_json_config(config_file)

        using_bam <- FALSE
        if (!is.null(in_bams)) {
            if (any(!file.exists(in_bams))) {
                stop("Please make sure all BAM file exist")
            }
            if (!all(file.exists(paste0(in_bams, ".bai")) | file.exists(paste0(in_bams, ".csi")))) {
                stop("Please make sure every BAM file is indexed")
            } else if (length(in_bams) != length(fastqs)) {
                stop("Please make sure a BAM file exists for every fastq file")
            }
            using_bam <- TRUE
            config$pipeline_parameters$do_genome_alignment <- FALSE
        }

        # setup of internal arguments which hold output files and intermediate files
        isoform_gff3 <- paste(outdir, "isoform_annotated.gff3", sep = "/")
        isoform_gff3_f <- paste(outdir, "isoform_annotated.filtered.gff3",
            sep =
                "/"
        )
        FSM_anno_out <- paste(outdir, "isoform_FSM_annotation.csv", sep = "/")
        raw_splice_isoform <- paste(outdir, "splice_raw.gff3", sep = "/")
        tss_tes_stat <- paste(outdir, "tss_tes.bedgraph", sep = "/")
        transcript_fa <- paste(outdir, "transcript_assembly.fa", sep = "/")
        transcript_fa_idx <- paste(outdir, "transcript_assembly.fa.fai",
            sep =
                "/"
        )
        tmp_bed <- paste(outdir, "tmp_splice_anno.bed12", sep = "/")


        tr_badcov_cnt_csvs <- paste(outdir, paste(samples, "transcript_count.bad_coverage.csv.gz", sep = "_"), sep = "/")
        tr_cnt_csvs <- paste(outdir, paste(samples, "transcript_count.csv.gz", sep = "_"), sep = "/")
        tmp_bams <- paste(outdir, paste(samples, "tmp_align.bam", sep = "_"), sep = "/")
        tmp_sams <- paste(outdir, paste(samples, "tmp_align.sam", sep = "_"), sep = "/")
        genome_bams <- paste(outdir, paste(samples, "align2genome.bam", sep = "_"), sep = "/")
        realign_bams <- paste(outdir, paste(samples, "realign2transcript.bam", sep = "_"), sep = "/")

        cat("#### Input parameters:\n")
        print_config(config)
        cat("\tgene annotation:", annot, "\n")
        cat("\tgenome fasta:", genome_fa, "\n")
        if (using_bam) {
            cat("\tinput bam:", paste0(in_bams, sep = "\n"), "\n")
            genome_bams <- in_bams
        }
        cat("\tinput fastqs:", paste0(fastqs, sep = "\n"), "\n")
        cat("\toutput directory:", outdir, "\n")
        cat("\tdirectory containing minimap2:", minimap2_dir, "\n")

        # align reads to genome
        # if (!using_bam && config$pipeline_parameters$do_genome_alignment) {
        if (config$pipeline_parameters$do_genome_alignment) {
            cat("#### Aligning reads to genome using minimap2\n")

            if (config$alignment_parameters$use_junctions) {
                gff3_to_bed12(minimap2_dir, annot, tmp_bed)
            }
            for (i in 1:length(samples)) {
                cat(paste0(c("\tAligning sample ", samples[i], "...\n")))
                minimap2_align(
                    minimap2_dir,
                    genome_fa,
                    fastqs[i],
                    tmp_sams[i],
                    no_flank = config$alignment_parameters$no_flank,
                    bed12_junc = if (config$alignment_parameters$use_junctions) {
                        tmp_bed
                    } else {
                        NULL
                    }
                )
                samtools_as_bam(tmp_sams[i], tmp_bams[i])
                samtools_sort_index(tmp_bams[i], genome_bams[i])
                file.remove(tmp_sams[i])
                file.remove(tmp_bams[i])
            }
            if (config$alignment_parameters$use_junctions) {
                file.remove(tmp_bed)
            }
        } else {
            cat("#### Skip aligning reads to genome\n")
        }

        # find isofroms
        isoform_objects <-
            find_isoform_multisample(
                annot,
                genome_bams,
                isoform_gff3,
                tss_tes_stat,
                genome_fa,
                transcript_fa,
                downsample_ratio,
                config,
                raw_splice_isoform
            )

        # realign to transcript
        # if (!using_bam && do_read_realign) {
        if (do_read_realign) {
            cat("#### Realign to transcript using minimap2\n")
            for (i in 1:length(samples)) {
                cat(paste0(c("\tRealigning sample ", samples[i], "...\n")))
                minimap2_tr_align(minimap2_dir, transcript_fa, fastqs[i], tmp_sams[i])
                samtools_as_bam(tmp_sams[i], tmp_bams[i])
                samtools_sort_index(tmp_bams[i], realign_bams[i])
                file.remove(tmp_sams[i])
                file.remove(tmp_bams[i])
            }
        } else {
            cat("#### Skip read realignment\n")
        }

        # quantification
        # TODO: implement filtering in R
        if (config$pipeline_parameters$do_transcript_quantification) {
            cat("#### Generating transcript count matrix\n")
            for (i in 1:length(samples)) {
                parse_realign <-
                    parse_realigned_bam(
                        realign_bams[i],
                        transcript_fa_idx,
                        # config$isoform_parameters$Min_sup_cnt,
                        1,
                        config$transcript_counting$min_tr_coverage,
                        config$transcript_counting$min_read_coverage
                    )
                tr_cnt <- wrt_tr_to_csv(
                    parse_realign$bc_tr_count_dict,
                    isoform_objects$transcript_dict_i,
                    tr_cnt_csvs[i],
                    isoform_objects$transcript_dict,
                    config$global_parameters$has_UMI
                )
                wrt_tr_to_csv(
                    parse_realign$bc_tr_badcov_count_dict,
                    isoform_objects$transcript_dict_i,
                    tr_badcov_cnt_csvs[i],
                    isoform_objects$transcript_dict,
                    config$global_parameters$has_UMI
                )
                # annotate_filter_gff(
                #    isoform_gff3,
                #    annot,
                #    isoform_gff3_f,
                #    FSM_anno_out,
                #    tr_cnt,
                #    config$isoform_parameters$Min_sup_cnt
                # )
            }
            annotate_full_splice_match_all_sample(FSM_anno_out, isoform_gff3, annot)
        } else {
            cat("#### Skip transcript quantification\n")
        }

        sce_list <- as.list(1:length(samples))
        names(sce_list) <- samples
        load_genome_anno <- rtracklayer::import(annot, feature.type = c("exon", "utr"))

        for (i in 1:length(samples)) {
            out_files <- list(
                "annot" = annot,
                "genome_fa" = genome_fa,
                "counts" = tr_cnt_csvs[i],
                "isoform_annotated" = isoform_gff3,
                "transcript_assembly" = transcript_fa,
                "config" = config_file,
                "align_bam" = genome_bams[i],
                "realign2transcript" = realign_bams[i],
                "tss_tes" = tss_tes_stat,
                "outdir" = outdir,
                "fsm_annotation" = FSM_anno_out
            )
            sce_list[[i]] <- generate_sc_singlecell(out_files, load_genome_anno = load_genome_anno)
        }

        return(sce_list)
    }